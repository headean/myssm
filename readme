2017/08/04
自动生成的 mybatis 的接口和映射文件的方式并未使用，仅在maven管理中加入了该配置。
数据库使用 MySQL ，配置文件存在一个 utf-8 转码问题未解决。


2017/08/18
SpringMVC配置：http://blog.csdn.net/uniqueweimeijun/article/details/72636481
SpringMVC和Spring的配置文件扫描包详解

1.注解扫描：扫描包下的所有使用了@Component注解的类，自动注册到容器中，同时也扫描@Controller，@Service，@Respository这三个注解，因为他们是继承自@Component。
<context:component-scan base-package="com.springmvc.test" />

1.1有上面配置，这个可省略。上面配置默认打开以下配置。以下配置会默认声明了@Required、@Autowired、 @PostConstruct、@PersistenceContext、@Resource、@PreDestroy等注解。
<context:annotation-config/>

2.SpringMVC必须配置，声明了@RequestMapping、@RequestBody、@ResponseBody等。并且，该配置默认加载很多的参数绑定方法，比如json转换解析器等。
<mvc:annotation-driven />
springmvc通过上边这个注解的方式可以代替处理器映射器和处理器适配器
而上面这句配置spring3.1之前的版本和以下配置方式等价
    <!-- 配置注解控制器映射器,它是SpringMVC中用来将Request请求URL到映射到具体Controller -->
    <bean class="org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping"/>
    <!-- 配置注解控制器映射器,它是SpringMVC中用来将具体请求映射到具体方法 -->
    <bean class="org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter"/>
spring3.1之后的版本和以下配置方式等价
    <!--配置注解控制器映射器,它是SpringMVC中用来将Request请求URL到映射到具体Controller-->
    <bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"/>
    <!--配置注解控制器映射器,它是SpringMVC中用来将具体请求映射到具体方法-->
    <bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"/>


2017/08/19
Mybatis配置：http://www.cnblogs.com/digdeep/p/4512368.html

    <!-- 引入 jdbc.properties 属性文件的两种方法 -->
    <context:property-placeholder location="classpath:jdbc.properties"/>

    <bean id="propertyConfigurer"
        class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
        <property name="location" value="classpath:jdbc.properties" />
    </bean>

修改 pom.xml 文件，将 mysql-connection-6.0.6 改为 mysql-connection-5.1.26 版本
修改数据库配置文件
driverClassName = com.mysql.jdbc.Driver
#jdbc_url = jdbc:mysql://127.0.0.1/myssm;
jdbc_url = jdbc\:mysql\://localhost\:3306/test
jdbc_username = root
jdbc_password = 123456

2017/08/20
继承HttpServlet出问题，因为没有把Tomcat的依赖加入Module。
此处，直接将Tomcat所在本地路径中的lib文件夹下的servlet-api.jar包，并没有加入整个Tomcat，后续有需要再作调整。

2017/08/21
昨晚不知怎么的就是睡不着，现在六点多起床看视频，哎。

关于service层中dao层对象userMapper报错问题，已找到解决方法，就是严格按照Spring注解方式。
参照：http://blog.csdn.net/busbanana/article/details/72954669




2017/08/22
log4j2 日志：
    http://www.cnblogs.com/zhangpengshou/p/5128050.html
    http://blog.csdn.net/lu8000/article/details/25754415

1、定义：log4j2 指log4j 2.X及以上版本
2、安装：
    log4j-core-xx.jar
    log4j-api-xx.jar
3、配置引用：
    import org.apache.logging.log4j.LogManager;
    import org.apache.logging.log4j.Logger;

    static Logger logger = LogManager.getLogger(Test.class.getName());

配置文件位置位于：src根目录下，即使没有配置文件的话也不会报错，默认以console的形式进行输出。http://www.cnblogs.com/hafiz/p/6170702.html
log4j2配置文件与log4（1.X版本的有很大不同），只能采用.xml、.json或者 .jsn格式，具体配置如下（${web:rootDir} 表示web根目录）：

<?xml version="1.0" encoding="UTF-8"?>

<configuration status="error">
    <!--先定义所有的appender-->
    <appenders>
        <!--这个输出控制台的配置-->
        <Console name="Console" target="SYSTEM_OUT">
            <!--这个是输出日志的格式-->
            <PatternLayout pattern="%d{HH:mm:ss.SSS} %-5level %class{36} %L %M - %msg%xEx%n"/>
        </Console>
        <!--文件会打印出所有信息，这个log每次运行程序会自动清空，由append属性决定，适合临时测试用-->
        <File name="Error" fileName="${web:rootDir}/logs/error.log" append="false">
            <!--文件只记录level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）-->
            <ThresholdFilter level="error" onMatch="ACCEPT" onMismatch="DENY"/>
            <PatternLayout charset="UTF-8" pattern="%d{HH:mm:ss.SSS} %-5level %class{36} %L %M - %msg%xEx%n"/>
        </File>

        <!--这个会打印出所有的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档-->
        <RollingFile name="RollingFile" fileName="${web:rootDir}/logs/history.log"
                     filePattern="log/$${date:yyyy-MM}/history-%d{MM-dd-yyyy}-%i.log.gz">
            <PatternLayout charset="UTF-8" pattern="%d{yyyy-MM-dd 'at' HH:mm:ss z} %-5level %class{36} %L %M - %msg%xEx%n"/>
            <SizeBasedTriggeringPolicy size="50MB"/>
        </RollingFile>
    </appenders>
    <!--然后定义logger，只有定义了logger并引入的appender，appender才会生效-->
    <loggers>
        <!--建立一个默认的root的logger-->
        <root level="trace">
            <appender-ref ref="Error"/>
            <appender-ref ref="RollingFile"/>
            <appender-ref ref="Console"/>
        </root>
    </loggers>
</configuration>

4、普通项目和web项目：
对于普通项目来讲，进行以上配置完成后即可以正常使用，对于web项目来讲，是不会生成日志文件的。需要在web.xml里面<web-app>根节点下添加如下配置：

<!-- log4j2.x start  -->
<listener>
    <listener-class>org.apache.logging.log4j.web.Log4jServletContextListener</listener-class>
</listener>
<filter>
    <filter-name>log4jServletFilter</filter-name>
    <filter-class>org.apache.logging.log4j.web.Log4jServletFilter</filter-class>
</filter>
<filter-mapping>
    <filter-name>log4jServletFilter</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>
<!-- log4j2.x end -->

报错问题：ERROR StatusLogger No log4j2 configuration file found. Using default configuration: logging only errors to the console.
参考 http://blog.csdn.net/axwolfer/article/details/40718609
运行时提示没有找到Log4j2的配置文件，使用默认配置，只显示error到控制台。
缺省的配置等同于如下配置，其中Root指定的level是error，所有只输出了error和fatal级别的日志。
<?xml version="1.0" encoding="UTF-8"?>
<Configuration status="WARN">
    <Appenders>
      <Console name="Console" target="SYSTEM_OUT">
        <PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/>
        </Console>
    </Appenders>
    <Loggers>
     <Root level="error">
        <AppenderRef ref="Console"/>
     </Root>
    </Loggers>
</Configuration>

Junit单元测试
junit generator自动生成测试代码默认路径和maven项目标准测试目录不同问题：https://my.oschina.net/laugh2last/blog/169352
outpath设置为${SOURCEPATH}/../../test/java/${PACKAGE}/${FILENAME}【default template选junit4】
在待编写测试的java类源码块上按快捷键（缺省）：alt+insert 或ctrl+shift+T

简单的方式参考：http://blog.csdn.net/lzjqcc/article/details/72663346



